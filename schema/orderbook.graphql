################## OrderBook
# Require an Event in the constructor of the contract
# type   @entity {
#     "Address of the OrderBook contract"
#     id: ID!
#     "Deployer of the OrderBook"
#     deployer: Bytes!
#     "Block the contract was deployed"
#     deployBlock: Int!
#     "Timestamp for block the contract was deployed"
#     deployTimestamp: Int!
# }

# Created with the first OrderLive event, then updated on the corresponding OrderDead/OrderLive events
type Order @entity {
  id: ID! # use the hash of the order from OrderLive.orde / OrderDead.order
  "Owner of the Order"
  owner: Bytes!
  "Input token"
  inputToken: ERC20!
  "Input token vault"
  inputTokenVault: TokenVault! # Match on {Order.inputVaultId}-{owner}-{inputToken}
  "Input vault"
  inputVault: Vault! # Link by {Order.inputVaultId}-{owner}
  "Output token"
  outputToken: ERC20!
  "Output token vault"
  outputTokenVault: TokenVault! # Match on {Order.outputVault}-{owner}-{outputToken}
  "Output vault"
  outputVault: Vault! # Link by {Order.outputVaultId}-{owner}
  "Whether tracking is enabled for this Order"
  tracking: BigInt
  "The VM state"
  vmState: Bytes!
  # update to true on OrderLive events where the hash of OrderLive.order matches the ID of this order.
  # update to false on OrderDead events where the hash of OrderDead.order matches the ID of this order.
  "Whether the order is live or dead"
  orderLiveness: Boolean
}

# Created and updated whenever an OrderLive event occurs
# ALSO created and updated when a pair of Clear/AfterClear events occur
type Vault @entity {
  id: ID! #{vaultId}-{owner}
  "The owner of this Vault"
  owner: Bytes!
  "Tokens in this Vault"
  tokenVaults: [TokenVault!]
  "Deposits into this Vault"
  deposits: [VaultDeposit!] # add whenever a Deposit event occurs for this {vaultId}-{owner}
  "Withdrawals from this Vault"
  withdraws: [VaultWithdraw!] # add whenver a Withdraw event occurs for this {vaultId}-{owner}
}

# Represents the balance of one ERC20 token for one vaultId, one owner
# Created after an OrderLive event occurs
# Updated:
# On each Deposit or Withdraw event for this {vaultId}-{owner}-{token} (see below for changes)
# OR
# On each Clear event that references an Order for this {vaultId}-{owner}-{token} (see below for changes)
type TokenVault @entity {
  id: ID! #{vaultId}-{owner}-{token}
  "The owner of this Vault"
  owner: Bytes! # From Deposit.sender / Withdraw.sender
  "The id of this vault"
  vaultId: BigInt!
  "The token that has a balance for this vault and owner."
  token: ERC20!
  # Add to this value:
  # Deposit.amount when there is a matching Deposit event for {vaultId}-{owner}-{token}
  # OR AfterClear.stateChange.aInput when there is a Clear event that matches {Clear.a_.inputVault}-{Clear.a_.owner}-{Clear.a_.inputToken}
  # OR AfterClear.stateChange.bInput when there is a Clear event that matches {Clear.b_.inputVault}-{Clear.b_.owner}-{Clear.b_.inputToken}
  # Subtract from this value:
  # Withdraw.amount when there is a matching Withdraw event for {vaultId}-{owner}-{token}
  "The balance of this token, for this vault, for this owner"
  balance: BigInt! # updated on every Deposit/Withdraw event that occurs for this {vaultId}-{owner}-{token}
  # Add to array:
  # when {Order.inputVault}-{Order.owner}-{Order.inputToken} match this TokenVault
  # OR when {Order.outputVault}-{Order.owner}-{Order.outputToken} match this TokenVault
  "Orders that reference this vault, owner and token"
  orders: [Order!]
  # Add to array:
  # when {Clear.a_.inputVault}-{Clear.a_.owner}-{Clear.a_.inputToken} match this TokenVault
  # OR when {Clear.b_.outputVault}-{Clear.b_.owner}-{Clear.b_.outputToken} match this TokenVault
  "OrderClears that reference this vault, owner and token"
  orderClears: [OrderClear!]
}

# Created for every Deposit event
type VaultDeposit @entity {
  id: ID! # use txhash of the event
  "The transaction sender of this deposit"
  sender: Bytes! # Deposit.sender
  "The token that was deposited"
  token: ERC20! # Deposit.config.token
  "The vaultId that was deposited into"
  vaultId: BigInt! # Deposit.config.vaultId
  "The Vault that was deposited into"
  vault: Vault! # map by {Deposit.config.vaultId}-{sender}
  "The amount that was deposited"
  amount: BigInt! # Deposit.config.amount
  "The current balance of this token for this Vault"
  tokenVault: TokenVault! # map by {Deposit.config.vaultId}-{Deposit.sender}-{Deposit.config.token}
}

# Created for every Withdraw event
type VaultWithdraw @entity {
  id: ID! # use txhash of the event
  "The transaction sender of this withdrawal"
  sender: Bytes! # Withdrawal.sender
  "The token that was withdrawn"
  token: ERC20! # Withdraw.config.token
  "The vaultId that was withdrawn from"
  vaultId: BigInt! # Withdraw.config.vaultId
  "The Vault that was withdrawn from"
  vault: Vault! # map by {Withdraw.config.vaultId}-{sender}
  "The amount that was requested be withdrawn"
  requestedAmount: BigInt! # Withdraw.config.amount
  "The amount that was withdrawn"
  amount: BigInt! # Withdraw.amount
  "The current balance of this token for this Vault"
  tokenVault: TokenVault! # map by {Withdraw.config.vaultId}-{Withdraw.sender}-{Withdraw.config.token}
}

# Created for every pair of AfterClear/Clear events
type OrderClear @entity {
  id: ID! # txhash
  "The sender who cleared the Orders"
  sender: Bytes! # Clear.sender
  "The clearer who cleared this order"
  clearer: Bytes! # from Clear.sender
  "Order A being cleared"
  orderA: Order! # map by hash(Clear.a_)
  "Order B being cleared"
  orderB: Order! # map by hash(Clear.b_)
  "The owners of the Orders that were cleared [Order A, Order B]"
  owners: [Bytes!] # [Clear.a_.owner, Clear.b_.owner]
  "The token cleared into Order A"
  aInput: ERC20! # Clear.a_.inputToken
  "The token cleared into Order B"
  bInput: ERC20! # Clear.b_.inputToken
  "The amount cleared into Order A"
  aInputAmount: BigInt! #AfterClear.stateChange.aInput
  "The amount cleared into Order B"
  bInputAmount: BigInt! #AfterClear.stateChange.bInput
  "The bounty paid when this order was cleared"
  bounty: Bounty! # map by unique id created - see Bounty entity
  "The state change that occured because of this Clear"
  stateChange: OrderClearStateChange # map by unique id created - see OrderClearStateChange entity
}

# Created when each OrderClear entity is created
type Bounty @entity {
  id: ID! # tx hash
  "The clearer who received this bounty"
  clearer: Bytes! # from Clear.sender
  "The Clear event that paid this bounty"
  orderClear: OrderClear!
  "The Vault that bounty token A was deposited into"
  bountyVaultA: Vault! # map by {Clear.bountyConfig.aVaultId}-{Clear.sender}
  "The Vault that bounty token B was deposited into"
  bountyVaultB: Vault! # map by {Clear.bountyConfig.bVaultId}-{Clear.sender}
  "The A token for the bounty"
  bountyTokenA: ERC20! # Clear.a_.outputToken
  "The B token for the bounty"
  bountyTokenB: ERC20! # Clear.b_.outputToken
  "The amount paid for bounty token A"
  bountyAmountA: BigInt # AfterClear.stateChange.aOutput - AfterClear.stateChange.bInput
  "The amount paid for bounty token B"
  bountyAmountB: BigInt # AfterClear.stateChange.bOutput - AfterClear.stateChange.aInput
}

# Create when an OrderClear entity is created
type OrderClearStateChange @entity {
  id: ID! # create a unqiue ID when OrderClear entity is created
  aOutput: BigInt! # AfterClear.stateChange.aOutput
  bOutput: BigInt! # AfterClear.stateChange.bOutput
  aInput: BigInt! # AfterClear.stateChange.aInput
  bInput: BigInt! # AfterClear.stateChange.bInput
}

################## OrderBook

# Created when an order is made.
# Updated after each Clear/AfterClear event that match with the hash Order
type ClearedOrder @entity {
  id: ID! # Hash of the order
  funds: BigInt! # Funds were cleared from the hashed order to anyone
  order: Order! # The related order
  clearedCounterparties: [ClearedCounterparty!] # All the Cleared Counterparties with the same hash order
}

# Created when an AfterClear is emitted
# Updated after each Clear/AfterClear event that match with the hash Order and ownerAddress
type ClearedCounterparty @entity {
  id: ID! # ${Hash of the order} - ${counterpartyAddress}
  funds: BigInt! # Fund that were cleared to counterparty address
  order: Order! # The related order
}

# Created and update after Order is emitted and match the inputToken and outputToken
type Pair @entity {
  id: ID! # ${inputToken} - ${outputToken}
  inputToken: Bytes!
  outputToken: Bytes!
  orders: [Order!] # Orders that match the same input/output Tokens
}
