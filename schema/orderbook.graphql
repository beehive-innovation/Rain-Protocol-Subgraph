################## OrderBook

# Created with AddOrder
type IO @entity {
  id: ID!
  index: BigInt!
  token: ERC20!
  vault: Vault!
  tokenVault: TokenVault!
}

# Created with the first AddOrder event, then updated on the corresponding OrderDead/OrderLive events
type Order @entity {
  id: ID! # use the hash of the order
  "Owner of the Order"
  owner: Bytes!

  transactionHash: Bytes!

  "validInputs"
  validInputs: [IO!]

  "validOutputs"
  validOutputs: [IO!]

  "interpreter"
  interpreter: Bytes!

  "Whether the order is live or dead"
  orderLive: Boolean

  dispatch: BigInt!

  handleIODispatch: BigInt!

  timestamp: BigInt!

  data: Bytes!

  stateConfig: ExpressionStateConfig!
}

# Created and updated whenever an OrderLive event occurs
# ALSO created and updated when a pair of Clear/AfterClear events occur

type Vault @entity {
  id: ID! #{vaultId}-{owner}
  "The owner of this Vault"
  owner: Bytes!

  "Tokens in this Vault"
  tokenVaults: [TokenVault!]

  "Deposits into this Vault"
  deposits: [VaultDeposit!] # add whenever a Deposit event occurs for this {vaultId}-{owner}
  "Withdrawals from this Vault"
  withdraws: [VaultWithdraw!] # add whenver a Withdraw event occurs for this {vaultId}-{owner}
}

type TokenVault @entity {
  id: ID! #{vaultId}-{owner}-{token}
  "The owner of this Vault"
  owner: Bytes! # From Deposit.sender / Withdraw.sender
  "The id of this vault"
  vaultId: BigInt!

  "The token that has a balance for this vault and owner."
  token: ERC20!

  # Add to this value:
  # Deposit.amount when there is a matching Deposit event for {vaultId}-{owner}-{token}
  # OR AfterClear.stateChange.aInput when there is a Clear event that matches {Clear.a_.inputVault}-{Clear.a_.owner}-{Clear.a_.inputToken}
  # OR AfterClear.stateChange.bInput when there is a Clear event that matches {Clear.b_.inputVault}-{Clear.b_.owner}-{Clear.b_.inputToken}
  # Subtract from this value:
  # Withdraw.amount when there is a matching Withdraw event for {vaultId}-{owner}-{token}

  "The balance of this token, for this vault, for this owner"
  balance: BigInt! # updated on every Deposit/Withdraw event that occurs for this {vaultId}-{owner}-{token}
  # Add to array:
  # when {Order.inputVault}-{Order.owner}-{Order.inputToken} match this TokenVault
  # OR when {Order.outputVault}-{Order.owner}-{Order.outputToken} match this TokenVault

  "Orders that reference this vault, owner and token"
  orders: [Order!]

  # Add to array:
  # when {Clear.a_.inputVault}-{Clear.a_.owner}-{Clear.a_.inputToken} match this TokenVault
  # OR when {Clear.b_.outputVault}-{Clear.b_.owner}-{Clear.b_.outputToken} match this TokenVault
  "OrderClears that reference this vault, owner and token"
  orderClears: [OrderClear!]
}

# Created for every Deposit event
type VaultDeposit @entity {
  id: ID! # use txhash of the event
  "The transaction sender of this deposit"
  sender: Bytes! # Deposit.sender
  "The token that was deposited"
  token: ERC20! # Deposit.config.token
  "The vaultId that was deposited into"
  vaultId: BigInt! # Deposit.config.vaultId
  "The Vault that was deposited into"
  vault: Vault! # map by {Deposit.config.vaultId}-{sender}
  "The amount that was deposited"
  amount: BigInt! # Deposit.config.amount
  "The current balance of this token for this Vault"
  tokenVault: TokenVault! # map by {Deposit.config.vaultId}-{Deposit.sender}-{Deposit.config.token}
  timestamp: BigInt! #timestamp of tx
}

# Created for every Withdraw event
type VaultWithdraw @entity {
  id: ID! # use txhash of the event
  "The transaction sender of this withdrawal"
  sender: Bytes! # Withdrawal.sender
  "The token that was withdrawn"
  token: ERC20! # Withdraw.config.token
  "The vaultId that was withdrawn from"
  vaultId: BigInt! # Withdraw.config.vaultId
  "The Vault that was withdrawn from"
  vault: Vault! # map by {Withdraw.config.vaultId}-{sender}
  "The amount that was requested be withdrawn"
  requestedAmount: BigInt! # Withdraw.config.amount
  "The amount that was withdrawn"
  amount: BigInt! # Withdraw.amount
  "The current balance of this token for this Vault"
  tokenVault: TokenVault! # map by {Withdraw.config.vaultId}-{Withdraw.sender}-{Withdraw.config.token}
  timestamp: BigInt! #timestamp of tx
}

# Created for every pair of AfterClear/Clear events
type OrderClear @entity {
  id: ID! # timestamp
  "The sender who cleared the Orders"
  sender: Bytes! # Clear.sender
  "The clearer who cleared this order"
  clearer: Bytes! # from Clear.sender
  "Order A being cleared"
  orderA: Order! # map by hash(Clear.a_)
  "Order B being cleared"
  orderB: Order! # map by hash(Clear.b_)
  "The owners of the Orders that were cleared [Order A, Order B]"
  owners: [Bytes!] # [Clear.a_.owner, Clear.b_.owner]
  "The token input index cleared into Order A"
  aInputIOIndex: BigInt!

  "The token output index cleared into Order A"
  aOutputIOIndex: BigInt!

  "The token input index cleared into Order B"
  bInputIOIndex: BigInt!

  "The token output index cleared into Order B"
  bOutputIOIndex: BigInt!

  "The bounty paid when this order was cleared"
  bounty: Bounty! # map by unique id created - see Bounty entity
  "The state change that occured because of this Clear"
  stateChange: OrderClearStateChange # map by unique id created - see OrderClearStateChange entity
}

# Created for every pair of TakeOrder events
type TakeOrderEntity @entity {
  id: ID! # txhash
  sender: Bytes!
  order: Order!
  input: BigInt!
  output: BigInt!
  inputIOIndex: BigInt! # index of input token for Input Token Array
  outputIOIndex: BigInt! # index of output token for Output Token Array
  inputToken: ERC20! # input token
  outputToken: ERC20! # output token
  timestamp: BigInt!
}

# Created when each OrderClear entity is created
type Bounty @entity {
  id: ID! # create a unique ID when OrderClear entity is created
  "The clearer who received this bounty"
  clearer: Bytes! # from Clear.sender
  "The Clear event that paid this bounty"
  orderClear: OrderClear!

  "The Vault that bounty token A was deposited into"
  bountyVaultA: Vault! # map by {Clear.bountyConfig.aVaultId}-{Clear.sender}
  "The Vault that bounty token B was deposited into"
  bountyVaultB: Vault! # map by {Clear.bountyConfig.bVaultId}-{Clear.sender}
  # Not Including Tokens , bounty referenced by VaultA And VaultB

  "The A token for the bounty"
  bountyTokenA: ERC20! # Clear.a_.outputToken
  "The B token for the bounty"
  bountyTokenB: ERC20! # Clear.b_.outputToken
  "The amount paid for bounty token A"
  bountyAmountA: BigInt # AfterClear.stateChange.aOutput - AfterClear.stateChange.bInput
  "The amount paid for bounty token B"
  bountyAmountB: BigInt # AfterClear.stateChange.bOutput - AfterClear.stateChange.aInput
}

# Create when an OrderClear entity is created
type OrderClearStateChange @entity {
  id: ID! # create a unqiue ID when OrderClear entity is created
  aOutput: BigInt! # AfterClear.stateChange.aOutput
  bOutput: BigInt! # AfterClear.stateChange.bOutput
  aInput: BigInt! # AfterClear.stateChange.aInput
  bInput: BigInt! # AfterClear.stateChange.bInput
}

################## OrderBook
