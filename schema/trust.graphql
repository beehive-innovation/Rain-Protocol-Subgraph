type Redeem @entity {
  id: ID!
  sale: Sale! # Sale entity
  caller: Bytes! #address indexed redeemer
  treasuryAsset: TreasuryAsset!
  redeemableERC20: RedeemableERC20! #address indexed redeemable
  redeemAmount: BigInt! #redeemAmounts[0]
  treasuryAssetAmount: BigInt! #redeemAmounts[1]
  deployBlock: BigInt! #the block the contract was deployed
  deployTimestamp: BigInt! #the timestamp the contract was deployed
}

type Holder implements HolderInterface @entity {
  id: ID! # {tokenAddress} - {holderAddress}
  address: Bytes!
  token: ERC20! # added this so Holder can be used for multiple ERC20 tokens
  balance: BigInt!
}

type TreasuryAsset @entity {
  id: ID!
  callers: [TreasuryAssetCaller!]
  redeems: [Redeem!]
  sale: Sale! # Sale entity
  address: Bytes!
  # Update after TreasuryAsset event on RedeemableERC20
  redeemableERC20: RedeemableERC20! #the RedeemableERC20 that emitted the TreasuryAsset event for this redeemable
  # Update after TreasuryAsset event on RedeemableERC20, and after Transfer events for this token
  balance: BigInt #this.balanceOf(RedeemableERC20.address())
  redemptionRatio: BigInt #this.balanceOf(RedeemableERC20.address()) / RedeemableERC20.totalSupply()
  #...Token interface fields
  # Update after TreasuryAsset event on RedeemableERC20
  deployBlock: BigInt! #the block the contract was deployed
  deployTimestamp: BigInt! #the timestamp the contract was deployed
  symbol: String
  totalSupply: BigInt
  decimals: Int
  name: String
}

type TreasuryAssetCaller @entity {
  id: ID!
  saleAddress: Bytes! #sale address
  redeemableERC20Address: Bytes!
  treasuryAsset: TreasuryAsset!
  caller: Bytes!
  deployBlock: BigInt!
  deployTimestamp: BigInt!
}

type UnknownNotice implements INotice @entity {
  id: ID!
  notices: [Notice!]
}
