// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class Trust__getContractsResultValue0Struct extends ethereum.Tuple {
  get reserveERC20(): Address {
    return this[0].toAddress();
  }

  get redeemableERC20(): Address {
    return this[1].toAddress();
  }

  get redeemableERC20Pool(): Address {
    return this[2].toAddress();
  }

  get seeder(): Address {
    return this[3].toAddress();
  }

  get tier(): Address {
    return this[4].toAddress();
  }

  get crp(): Address {
    return this[5].toAddress();
  }

  get pool(): Address {
    return this[6].toAddress();
  }
}

export class Trust__getDistributionProgressResultValue0Struct extends ethereum.Tuple {
  get distributionStatus(): i32 {
    return this[0].toI32();
  }

  get distributionStartBlock(): BigInt {
    return this[1].toBigInt();
  }

  get distributionEndBlock(): BigInt {
    return this[2].toBigInt();
  }

  get poolReserveBalance(): BigInt {
    return this[3].toBigInt();
  }

  get poolTokenBalance(): BigInt {
    return this[4].toBigInt();
  }

  get reserveInit(): BigInt {
    return this[5].toBigInt();
  }

  get minimumCreatorRaise(): BigInt {
    return this[6].toBigInt();
  }

  get seederFee(): BigInt {
    return this[7].toBigInt();
  }

  get redeemInit(): BigInt {
    return this[8].toBigInt();
  }
}

export class Trust__getTrustConfigResultValue0Struct extends ethereum.Tuple {
  get creator(): Address {
    return this[0].toAddress();
  }

  get minimumCreatorRaise(): BigInt {
    return this[1].toBigInt();
  }

  get seedERC20Factory(): Address {
    return this[2].toAddress();
  }

  get seeder(): Address {
    return this[3].toAddress();
  }

  get seederFee(): BigInt {
    return this[4].toBigInt();
  }

  get seederUnits(): i32 {
    return this[5].toI32();
  }

  get seederCooldownDuration(): i32 {
    return this[6].toI32();
  }

  get redeemInit(): BigInt {
    return this[7].toBigInt();
  }
}

export class Trust extends ethereum.SmartContract {
  static bind(address: Address): Trust {
    return new Trust("Trust", address);
  }

  creator(): Address {
    let result = super.call("creator", "creator():(address)", []);

    return result[0].toAddress();
  }

  try_creator(): ethereum.CallResult<Address> {
    let result = super.tryCall("creator", "creator():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  finalBalance(): BigInt {
    let result = super.call("finalBalance", "finalBalance():(uint256)", []);

    return result[0].toBigInt();
  }

  try_finalBalance(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("finalBalance", "finalBalance():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getContracts(): Trust__getContractsResultValue0Struct {
    let result = super.call(
      "getContracts",
      "getContracts():((address,address,address,address,address,address,address))",
      []
    );

    return result[0].toTuple() as Trust__getContractsResultValue0Struct;
  }

  try_getContracts(): ethereum.CallResult<
    Trust__getContractsResultValue0Struct
  > {
    let result = super.tryCall(
      "getContracts",
      "getContracts():((address,address,address,address,address,address,address))",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Trust__getContractsResultValue0Struct
    );
  }

  getDistributionProgress(): Trust__getDistributionProgressResultValue0Struct {
    let result = super.call(
      "getDistributionProgress",
      "getDistributionProgress():((uint8,uint32,uint32,uint256,uint256,uint256,uint256,uint256,uint256))",
      []
    );

    return result[0].toTuple() as Trust__getDistributionProgressResultValue0Struct;
  }

  try_getDistributionProgress(): ethereum.CallResult<
    Trust__getDistributionProgressResultValue0Struct
  > {
    let result = super.tryCall(
      "getDistributionProgress",
      "getDistributionProgress():((uint8,uint32,uint32,uint256,uint256,uint256,uint256,uint256,uint256))",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Trust__getDistributionProgressResultValue0Struct
    );
  }

  getDistributionStatus(): i32 {
    let result = super.call(
      "getDistributionStatus",
      "getDistributionStatus():(uint8)",
      []
    );

    return result[0].toI32();
  }

  try_getDistributionStatus(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "getDistributionStatus",
      "getDistributionStatus():(uint8)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  getTrustConfig(): Trust__getTrustConfigResultValue0Struct {
    let result = super.call(
      "getTrustConfig",
      "getTrustConfig():((address,uint256,address,address,uint256,uint16,uint16,uint256))",
      []
    );

    return result[0].toTuple() as Trust__getTrustConfigResultValue0Struct;
  }

  try_getTrustConfig(): ethereum.CallResult<
    Trust__getTrustConfigResultValue0Struct
  > {
    let result = super.tryCall(
      "getTrustConfig",
      "getTrustConfig():((address,uint256,address,address,uint256,uint16,uint16,uint256))",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTuple() as Trust__getTrustConfigResultValue0Struct
    );
  }

  minimumCreatorRaise(): BigInt {
    let result = super.call(
      "minimumCreatorRaise",
      "minimumCreatorRaise():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_minimumCreatorRaise(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "minimumCreatorRaise",
      "minimumCreatorRaise():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  pool(): Address {
    let result = super.call("pool", "pool():(address)", []);

    return result[0].toAddress();
  }

  try_pool(): ethereum.CallResult<Address> {
    let result = super.tryCall("pool", "pool():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  redeemInit(): BigInt {
    let result = super.call("redeemInit", "redeemInit():(uint256)", []);

    return result[0].toBigInt();
  }

  try_redeemInit(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("redeemInit", "redeemInit():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  seedERC20Factory(): Address {
    let result = super.call(
      "seedERC20Factory",
      "seedERC20Factory():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_seedERC20Factory(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "seedERC20Factory",
      "seedERC20Factory():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  seeder(): Address {
    let result = super.call("seeder", "seeder():(address)", []);

    return result[0].toAddress();
  }

  try_seeder(): ethereum.CallResult<Address> {
    let result = super.tryCall("seeder", "seeder():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  seederCooldownDuration(): i32 {
    let result = super.call(
      "seederCooldownDuration",
      "seederCooldownDuration():(uint16)",
      []
    );

    return result[0].toI32();
  }

  try_seederCooldownDuration(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "seederCooldownDuration",
      "seederCooldownDuration():(uint16)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  seederFee(): BigInt {
    let result = super.call("seederFee", "seederFee():(uint256)", []);

    return result[0].toBigInt();
  }

  try_seederFee(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("seederFee", "seederFee():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  seederUnits(): i32 {
    let result = super.call("seederUnits", "seederUnits():(uint16)", []);

    return result[0].toI32();
  }

  try_seederUnits(): ethereum.CallResult<i32> {
    let result = super.tryCall("seederUnits", "seederUnits():(uint16)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  successBalance(): BigInt {
    let result = super.call("successBalance", "successBalance():(uint256)", []);

    return result[0].toBigInt();
  }

  try_successBalance(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "successBalance",
      "successBalance():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  token(): Address {
    let result = super.call("token", "token():(address)", []);

    return result[0].toAddress();
  }

  try_token(): ethereum.CallResult<Address> {
    let result = super.tryCall("token", "token():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get config_(): ConstructorCallConfig_Struct {
    return this._call.inputValues[0].value.toTuple() as ConstructorCallConfig_Struct;
  }

  get trustRedeemableERC20Config_(): ConstructorCallTrustRedeemableERC20Config_Struct {
    return this._call.inputValues[1].value.toTuple() as ConstructorCallTrustRedeemableERC20Config_Struct;
  }

  get trustRedeemableERC20PoolConfig_(): ConstructorCallTrustRedeemableERC20PoolConfig_Struct {
    return this._call.inputValues[2].value.toTuple() as ConstructorCallTrustRedeemableERC20PoolConfig_Struct;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCallConfig_Struct extends ethereum.Tuple {
  get creator(): Address {
    return this[0].toAddress();
  }

  get minimumCreatorRaise(): BigInt {
    return this[1].toBigInt();
  }

  get seedERC20Factory(): Address {
    return this[2].toAddress();
  }

  get seeder(): Address {
    return this[3].toAddress();
  }

  get seederFee(): BigInt {
    return this[4].toBigInt();
  }

  get seederUnits(): i32 {
    return this[5].toI32();
  }

  get seederCooldownDuration(): i32 {
    return this[6].toI32();
  }

  get redeemInit(): BigInt {
    return this[7].toBigInt();
  }
}

export class ConstructorCallTrustRedeemableERC20Config_Struct extends ethereum.Tuple {
  get redeemableERC20Factory(): Address {
    return this[0].toAddress();
  }

  get name(): string {
    return this[1].toString();
  }

  get symbol(): string {
    return this[2].toString();
  }

  get tier(): Address {
    return this[3].toAddress();
  }

  get minimumStatus(): i32 {
    return this[4].toI32();
  }

  get totalSupply(): BigInt {
    return this[5].toBigInt();
  }
}

export class ConstructorCallTrustRedeemableERC20PoolConfig_Struct extends ethereum.Tuple {
  get redeemableERC20PoolFactory(): Address {
    return this[0].toAddress();
  }

  get reserve(): Address {
    return this[1].toAddress();
  }

  get reserveInit(): BigInt {
    return this[2].toBigInt();
  }

  get initialValuation(): BigInt {
    return this[3].toBigInt();
  }

  get finalValuation(): BigInt {
    return this[4].toBigInt();
  }

  get minimumTradingDuration(): BigInt {
    return this[5].toBigInt();
  }
}

export class AnonEndDistributionCall extends ethereum.Call {
  get inputs(): AnonEndDistributionCall__Inputs {
    return new AnonEndDistributionCall__Inputs(this);
  }

  get outputs(): AnonEndDistributionCall__Outputs {
    return new AnonEndDistributionCall__Outputs(this);
  }
}

export class AnonEndDistributionCall__Inputs {
  _call: AnonEndDistributionCall;

  constructor(call: AnonEndDistributionCall) {
    this._call = call;
  }
}

export class AnonEndDistributionCall__Outputs {
  _call: AnonEndDistributionCall;

  constructor(call: AnonEndDistributionCall) {
    this._call = call;
  }
}
